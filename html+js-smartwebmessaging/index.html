<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Tiro Web SDK - SMART Web Messaging</title>
        <link
            rel="stylesheet"
            href="https://atticus-assets.tiro.health/sdk-dev/latest/tiro-web-sdk.css"
        />
        <script
            src="https://browser.sentry-cdn.com/10.33.0/bundle.tracing.min.js"
            crossorigin="anonymous"
        ></script>
        <script>
            Sentry.init({
                dsn: "https://5b3c2798d1b788d50ee2f655ad3ca731@o4509350631292928.ingest.de.sentry.io/4510703453405264",
                tracesSampleRate: 1.0,
                integrations: [Sentry.browserTracingIntegration()],
            });
        </script>
        <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
        <style>
            /* Basic page layout */
            body {
                margin: 0;
                padding: 0;
                font-family:
                    system-ui,
                    -apple-system,
                    sans-serif;
            }

            main {
                max-width: 1200px;
                margin: 0 auto;
                padding: 2rem;
            }
        </style>
    </head>
    <body class="px-4 w-full">
        <main>
            <!-- Magic Clipboard Popover -->
            <div id="magic-clipboard-popover" popover>
                <div class="popover-header">
                    <h2>Magic Clipboard</h2>
                    <button
                        class="popover-close"
                        popovertarget="magic-clipboard-popover"
                        popovertargetaction="hide"
                    >
                        Ã—
                    </button>
                </div>
                <div class="popover-content">
                    <tiro-magic-clipboard
                        for="report-form"
                    ></tiro-magic-clipboard>
                </div>
            </div>
            <div class="flex justify-end mb-3 gap-2">
                <button
                    popovertarget="magic-clipboard-popover"
                    class="inline-flex items-center gap-2 px-3 py-1.5 text-sm font-medium rounded-md bg-blue-600 hover:bg-blue-700 text-white transition-colors"
                >
                    <svg
                        xmlns="http://www.w3.org/2000/svg"
                        width="16"
                        height="16"
                        viewBox="0 0 24 24"
                        fill="none"
                        stroke="currentColor"
                        stroke-width="2"
                        stroke-linecap="round"
                        stroke-linejoin="round"
                    >
                        <path
                            d="m21.64 3.64-1.28-1.28a1.21 1.21 0 0 0-1.72 0L2.36 18.64a1.21 1.21 0 0 0 0 1.72l1.28 1.28a1.2 1.2 0 0 0 1.72 0L21.64 5.36a1.2 1.2 0 0 0 0-1.72"
                        />
                        <path d="m14 7 3 3" />
                        <path d="M5 6v4" />
                        <path d="M19 14v4" />
                        <path d="M10 2v2" />
                        <path d="M7 8H3" />
                        <path d="M21 16h-4" />
                        <path d="M11 3H9" />
                    </svg>
                    Autofill
                </button>
            </div>
            <tiro-form-filler
                id="form-filler"
                sdc-endpoint-address="https://sdc-service-dev-wkrcomcqfq-ew.a.run.app/fhir/r5"
            ></tiro-form-filler>
        </main>

        <script src="https://atticus-assets.tiro.health/sdk-dev/latest/tiro-web-sdk.iife.js"></script>

        <script>
            // ===========================================
            // SMART Web Messaging Module
            // ===========================================
            const SmartWebMessaging = {
                messagingHandle: "smart-web-messaging",
                pendingRequests: new Map(),
                config: null,
                context: null,

                // Generate unique message ID
                generateMessageId() {
                    return crypto.randomUUID();
                },

                // Check if running in WebView2
                isWebView2() {
                    return window.chrome && window.chrome.webview;
                },

                // Check if running in iframe
                isIframe() {
                    return window.parent !== window;
                },

                // Send message to host
                sendMessage(message) {
                    console.log("[SWM] Sending:", message.messageType, message);

                    const doSend = () => {
                        if (this.isWebView2()) {
                            window.chrome.webview.postMessage(message);
                        } else if (this.isIframe()) {
                            window.parent.postMessage(message, "*");
                        } else {
                            console.warn(
                                "[SWM] No host available - message not sent",
                            );
                        }
                    };

                    // Wrap in Sentry span if available
                    if (
                        typeof Sentry !== "undefined" &&
                        typeof Sentry.startSpan === "function"
                    ) {
                        Sentry.startSpan(
                            {
                                op: "swm.send",
                                name: message.messageType || "response",
                            },
                            (span) => {
                                span.setAttribute(
                                    "swm.messageId",
                                    message.messageId,
                                );
                                span.setAttribute(
                                    "swm.messageType",
                                    message.messageType || null,
                                );
                                span.setAttribute(
                                    "swm.hasPayload",
                                    !!message.payload,
                                );
                                doSend();
                            },
                        );
                    } else {
                        doSend();
                    }
                },

                // Send request and wait for response
                sendRequest(messageType, payload = {}) {
                    return new Promise((resolve, reject) => {
                        const messageId = this.generateMessageId();
                        this.pendingRequests.set(messageId, {
                            resolve,
                            reject,
                        });

                        this.sendMessage({
                            messageId,
                            messagingHandle: this.messagingHandle,
                            messageType,
                            payload,
                        });

                        // Timeout after 30 seconds
                        setTimeout(() => {
                            if (this.pendingRequests.has(messageId)) {
                                this.pendingRequests.delete(messageId);
                                reject(
                                    new Error(
                                        `Request timeout: ${messageType}`,
                                    ),
                                );
                            }
                        }, 30000);
                    });
                },

                // Send event (no response expected)
                sendEvent(messageType, payload = {}) {
                    this.sendMessage({
                        messageId: this.generateMessageId(),
                        messagingHandle: this.messagingHandle,
                        messageType,
                        payload,
                    });
                },

                // Retry handshake until success or timeout
                retryHandshake(retryIntervalMs = 1000, timeoutMs = 30000) {
                    return new Promise((resolve, reject) => {
                        const startTime = Date.now();
                        let attemptCount = 0;
                        let resolved = false;
                        const attemptMessageIds = []; // Track all attempt messageIds

                        const cleanup = () => {
                            // Remove all pending requests for this handshake
                            attemptMessageIds.forEach((id) =>
                                this.pendingRequests.delete(id),
                            );
                        };

                        const onSuccess = (payload) => {
                            if (resolved) return; // Already resolved
                            resolved = true;
                            cleanup();
                            resolve(payload);
                        };

                        const attempt = () => {
                            if (resolved) return;

                            attemptCount++;
                            console.log(
                                `[SWM] Handshake attempt ${attemptCount}...`,
                            );

                            const messageId = this.generateMessageId();
                            attemptMessageIds.push(messageId);

                            // All attempts share the same success handler
                            this.pendingRequests.set(messageId, {
                                resolve: onSuccess,
                                reject: () => {}, // Individual timeouts don't reject
                            });

                            this.sendMessage({
                                messageId,
                                messagingHandle: this.messagingHandle,
                                messageType: "status.handshake",
                                payload: {},
                            });

                            // Schedule next attempt (keep old messageId active)
                            setTimeout(() => {
                                if (!resolved) {
                                    const remaining =
                                        timeoutMs - (Date.now() - startTime);
                                    if (remaining > 0) {
                                        attempt();
                                    }
                                }
                            }, retryIntervalMs);
                        };

                        // Overall timeout
                        setTimeout(() => {
                            if (!resolved) {
                                cleanup();
                                reject(
                                    new Error(
                                        `Handshake timeout after ${attemptCount} attempts`,
                                    ),
                                );
                            }
                        }, timeoutMs);

                        attempt();
                    });
                },

                // Handle incoming message from host
                handleMessage(message) {
                    console.log(
                        "[SWM] Received:",
                        message.messageType || "response",
                        message,
                    );

                    const doHandle = () => {
                        // Handle response to our request
                        if (message.responseToMessageId) {
                            const pending = this.pendingRequests.get(
                                message.responseToMessageId,
                            );
                            if (pending) {
                                if (
                                    message.payload &&
                                    message.payload.$type === "error"
                                ) {
                                    pending.reject(
                                        new Error(message.payload.errorMessage),
                                    );
                                } else {
                                    pending.resolve(message.payload);
                                }
                                if (!message.additionalResponsesExpected) {
                                    this.pendingRequests.delete(
                                        message.responseToMessageId,
                                    );
                                }
                            }
                            return;
                        }

                        // Handle host-initiated messages
                        if (message.messageType) {
                            this.handleHostMessage(message);
                        }
                    };

                    // Wrap in Sentry span if available
                    if (
                        typeof Sentry !== "undefined" &&
                        typeof Sentry.startSpan === "function"
                    ) {
                        Sentry.startSpan(
                            {
                                op: "swm.receive",
                                name: message.messageType || "response",
                            },
                            (span) => {
                                span.setAttribute(
                                    "swm.messageId",
                                    message.messageId ||
                                        message.responseToMessageId,
                                );
                                span.setAttribute(
                                    "swm.messageType",
                                    message.messageType || null,
                                );
                                span.setAttribute(
                                    "swm.isResponse",
                                    !!message.responseToMessageId,
                                );
                                doHandle();
                            },
                        );
                    } else {
                        doHandle();
                    }
                },

                // Handle messages initiated by host
                handleHostMessage(message) {
                    const handlers = {
                        "sdc.configure": () => this.handleConfigure(message),
                        "sdc.configureContext": () =>
                            this.handleConfigureContext(message),
                        "sdc.displayQuestionnaire": () =>
                            this.handleDisplayQuestionnaire(message),
                        "ui.form.requestSubmit": () =>
                            this.handleRequestSubmit(message),
                        "ui.form.persist": () => this.handlePersist(message),
                    };

                    const handler = handlers[message.messageType];
                    if (handler) {
                        handler();
                        // Send acknowledgment response
                        this.sendResponse(message.messageId, { $type: "base" });
                    } else {
                        console.warn(
                            "[SWM] Unknown message type:",
                            message.messageType,
                        );
                        this.sendResponse(message.messageId, {
                            $type: "error",
                            errorMessage: `Unknown message type: ${message.messageType}`,
                            errorType: "UnknownMessageTypeException",
                        });
                    }
                },

                // Send response to host message
                sendResponse(responseToMessageId, payload) {
                    this.sendMessage({
                        messageId: this.generateMessageId(),
                        responseToMessageId,
                        additionalResponsesExpected: false,
                        payload,
                    });
                },

                // Handle sdc.configure
                handleConfigure(message) {
                    this.config = message.payload;
                    console.log("[SWM] Configuration received:", this.config);
                    updateStatus("connected", "Configuration received");
                    checkReadyToInitialize();
                },

                // Handle sdc.configureContext
                handleConfigureContext(message) {
                    this.context = message.payload;
                    console.log("[SWM] Context received:", this.context);
                    checkReadyToInitialize();
                },

                // Handle sdc.displayQuestionnaire
                handleDisplayQuestionnaire(message) {
                    console.log(
                        "[SWM] Full displayQuestionnaire message:",
                        JSON.stringify(message, null, 2),
                    );

                    const { questionnaire, questionnaireResponse, context } =
                        message.payload;

                    // Merge context if provided
                    if (context) {
                        this.context = { ...this.context, ...context };
                    }

                    console.log("[SWM] Display questionnaire:", questionnaire);
                    console.log(
                        "[SWM] QuestionnaireResponse:",
                        questionnaireResponse,
                    );
                    console.log("[SWM] Context:", context);

                    if (!questionnaire) {
                        console.error(
                            "[SWM] No questionnaire found in payload:",
                            message.payload,
                        );
                        return;
                    }

                    initializeSDK(questionnaire, questionnaireResponse);
                },

                // Handle ui.form.requestSubmit
                handleRequestSubmit(message) {
                    console.log("[SWM] Submit requested by host");
                    handleSubmit();
                },

                // Handle ui.form.persist
                handlePersist(message) {
                    console.log("[SWM] Persist requested by host");
                    // TODO: Implement persist logic if SDK supports it
                },

                // Initialize message listener
                init() {
                    const self = this;

                    if (this.isWebView2()) {
                        // WebView2 mode
                        window.chrome.webview.addEventListener(
                            "message",
                            (event) => {
                                self.handleMessage(event.data);
                            },
                        );
                        console.log(
                            "[SWM] WebView2 message listener initialized",
                        );
                    } else if (this.isIframe()) {
                        // Iframe mode - listen for postMessage from parent
                        window.addEventListener("message", (event) => {
                            // Accept messages from parent window
                            if (event.source === window.parent) {
                                self.handleMessage(event.data);
                            }
                        });
                        console.log(
                            "[SWM] Iframe message listener initialized",
                        );
                    } else {
                        console.warn(
                            "[SWM] No host detected - running in standalone mode",
                        );
                        updateStatus(
                            "error",
                            "No host detected - embed in WebView2 or iframe",
                        );
                        return;
                    }

                    // Send handshake with retry (every 1 second, timeout after 30 seconds)
                    this.retryHandshake(1000, 30000)
                        .then(() => {
                            console.log("[SWM] Handshake successful");
                            updateStatus(
                                "waiting",
                                "Connected - waiting for configuration...",
                            );
                        })
                        .catch((err) => {
                            console.error("[SWM] Handshake failed:", err);
                            updateStatus(
                                "error",
                                "Handshake failed - host not responding",
                            );
                        });
                },
            };

            // ===========================================
            // SDK Integration (Web Components API)
            // ===========================================

            function checkReadyToInitialize() {
                // Auto-initialize is handled by sdc.displayQuestionnaire
                // This function can be used for status updates
                if (SmartWebMessaging.config) {
                    updateStatus(
                        "connected",
                        "Ready - waiting for questionnaire...",
                    );
                }
            }

            function initializeSDK(questionnaire, questionnaireResponse) {
                const formFiller = document.getElementById("form-filler");

                // Validate questionnaire
                if (!questionnaire) {
                    console.error("[SDK] No questionnaire provided");
                    updateStatus("error", "No questionnaire received");
                    return;
                }

                console.log("[SDK] Setting up form filler with:", {
                    questionnaire,
                    questionnaireResponse,
                    context: SmartWebMessaging.context,
                });

                // Build and set launch context from SWM context
                if (SmartWebMessaging.context) {
                    const launchContext = {};

                    // Convert array format to object format
                    if (
                        Array.isArray(
                            SmartWebMessaging.context.launchContext,
                        ) &&
                        SmartWebMessaging.context.launchContext.length > 0
                    ) {
                        SmartWebMessaging.context.launchContext.forEach(
                            (item) => {
                                if (item.name && item.contentResource) {
                                    launchContext[item.name] =
                                        item.contentResource;
                                }
                            },
                        );
                    }

                    if (Object.keys(launchContext).length > 0) {
                        formFiller.setAttribute(
                            "launch-context",
                            JSON.stringify(launchContext),
                        );
                        console.log("[SDK] Set launch-context:", launchContext);
                    }

                    console.log(
                        "[SDK] Using context from host:",
                        SmartWebMessaging.context,
                    );
                }

                // Set initial response if provided
                if (questionnaireResponse) {
                    formFiller.setAttribute(
                        "initial-response",
                        JSON.stringify(questionnaireResponse),
                    );
                    console.log("[SDK] Set initial-response");
                }

                // Set questionnaire last (triggers render)
                if (typeof questionnaire === "string") {
                    formFiller.setAttribute("questionnaire", questionnaire);
                } else {
                    formFiller.setAttribute(
                        "questionnaire",
                        JSON.stringify(questionnaire),
                    );
                }
                console.log("[SDK] Set questionnaire:", questionnaire);

                // Narrative automatically links via for="form-filler" attribute
                console.log(
                    "[SDK] Tiro Web SDK initialized with web components",
                );
            }

            // ===========================================
            // Action Handlers
            // ===========================================

            // Trigger form submission - fires tiro-submit event
            function handleSubmit() {
                const formFiller = document.getElementById("form-filler");

                if (!formFiller.questionnaire) {
                    console.warn("[Action] No form to submit");
                    return;
                }

                // Trigger form submission - this fires the tiro-submit event
                formFiller.submit();
            }

            // ===========================================
            // Sanitization Utilities
            // ===========================================

            /**
             * Recursively sanitizes a plain object by removing properties with null values.
             * Handles arrays, nested objects, and all JSON primitive types.
             * Returns a new object - does not mutate the original.
             *
             * @param {*} value - Any JSON-compatible value (object, array, string, number, boolean, null)
             * @returns {*} - Sanitized value with null properties removed
             */
            function sanitizeObject(value) {
                // Handle null - return undefined to signal removal
                if (value === null) {
                    return undefined;
                }

                // Handle primitives (string, number, boolean, undefined)
                if (typeof value !== "object") {
                    return value;
                }

                // Handle arrays - recursively sanitize each element, filter out undefined
                if (Array.isArray(value)) {
                    return value
                        .map(sanitizeObject)
                        .filter((item) => item !== undefined);
                }

                // Handle objects - recursively sanitize each property
                const result = {};
                for (const [key, val] of Object.entries(value)) {
                    const sanitized = sanitizeObject(val);
                    // Only include non-undefined values (null values become undefined)
                    if (sanitized !== undefined) {
                        result[key] = sanitized;
                    }
                }
                return result;
            }

            // Called from the tiro-submit event listener
            async function sendFormSubmission(questionnaireResponse) {
                // Mark as completed
                questionnaireResponse.status = "completed";

                // Sanitize response before sending
                questionnaireResponse = sanitizeObject(questionnaireResponse);
                console.log("[Action] Sanitized QuestionnaireResponse");

                // Generate narrative using SDCClient from form-filler
                const formFiller = document.getElementById("form-filler");
                try {
                    const narrative =
                        await formFiller.sdcClient.generateNarrative(
                            questionnaireResponse,
                        );
                    questionnaireResponse.text = narrative;
                    console.log(
                        "[Action] Generated narrative:",
                        questionnaireResponse.text,
                    );
                } catch (err) {
                    console.warn("[Action] Narrative generation error:", err);
                }

                const operationOutcome = {
                    resourceType: "OperationOutcome",
                    issue: [
                        {
                            severity: "information",
                            code: "informational",
                            diagnostics: "Form submitted successfully",
                        },
                    ],
                };

                SmartWebMessaging.sendRequest("form.submitted", {
                    response: questionnaireResponse,
                    outcome: operationOutcome,
                })
                    .then(() => {
                        console.log("[Action] Form submitted successfully");
                        updateStatus("connected", "Form submitted");
                    })
                    .catch((err) => {
                        console.error("[Action] Form submission failed:", err);
                        updateStatus(
                            "error",
                            "Submission failed: " + err.message,
                        );
                    });
            }

            function handleDone() {
                // Send ui.done event
                SmartWebMessaging.sendEvent("ui.done", {});
                console.log("[Action] Done signal sent");
                updateStatus("connected", "Done - closing...");
            }

            // ===========================================
            // UI Helpers
            // ===========================================
            function updateStatus(type, text) {
                console.log(`[Status] ${type}: ${text}`);
            }

            // ===========================================
            // Initialize
            // ===========================================
            document.addEventListener("DOMContentLoaded", () => {
                const formFiller = document.getElementById("form-filler");

                // Listen for form updates (for debugging/status)
                formFiller.addEventListener("tiro-update", (event) => {
                    console.log("[SDK] Form updated:", event.detail.response);
                });

                // Listen for form submission - sends response to host
                formFiller.addEventListener("tiro-submit", (event) => {
                    console.log("[SDK] Form submitted via tiro-submit event");
                    sendFormSubmission(event.detail.response);
                });

                // Listen for questionnaire ready
                formFiller.addEventListener("tiro-ready", (event) => {
                    console.log(
                        "[SDK] Questionnaire loaded:",
                        event.detail.questionnaire,
                    );
                    updateStatus("connected", "Questionnaire loaded");
                });

                // Listen for errors
                formFiller.addEventListener("tiro-error", (event) => {
                    console.error(
                        "[SDK] Error:",
                        event.detail.type,
                        event.detail.error,
                    );
                    updateStatus(
                        "error",
                        `Error: ${event.detail.error.message}`,
                    );
                });

                // Initialize SWM
                SmartWebMessaging.init();
            });
        </script>
    </body>
</html>
